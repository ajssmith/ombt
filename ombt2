#!/usr/bin/env python
#
#    Licensed to the Apache Software Foundation (ASF) under one
#    or more contributor license agreements.  See the NOTICE file
#    distributed with this work for additional information
#    regarding copyright ownership.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
#import eventlet
#eventlet.monkey_patch()

import abc
import argparse
import os
import socket
import sys
import threading
import time
import uuid
import logging
import math
from subprocess import Popen, STDOUT
try:
    from monotonic import monotonic as now
except ImportError:
    from time import time as now

from oslo_config import cfg
import oslo_messaging as om


# flags for running in the background
_DAEMON = False
_PARENT_FD = -1

RPC_CLIENT = 'RPCClient'
RPC_SERVER = 'RPCServer'
LISTENER = 'Listener'
NOTIFIER = 'Notifier'
EXCHANGE = 'ombt'
CLIENT_TOPIC = "client-%s"
DEFAULT_LEN = 1024


class Stats(object):
    """Manage a single statistic"""
    def __init__(self):
        self.min = None
        self.max = None
        self.total = 0
        self.count = 0
        self.average = None
        self.std_deviation = None
        self._sum_of_squares = 0

    def update(self, value):
        self._update(value)

    def merge(self, stats):
        self._update(stats.total, min_value=stats.min, max_value=stats.max, count=stats.count, squared=stats._sum_of_squares)

    def reset(self):
        self.__init__()

    def _update(self, value, min_value=None, max_value=None, count=1, squared=None):
        min_value = min_value or value
        max_value = max_value or value
        squared = squared or (value**2)

        if not self.min or min_value < self.min:
            self.min = min_value
        if not self.max or max_value > self.max:
            self.max = max_value
        self.total += value
        self.count += count
        self._sum_of_squares += squared
        n = float(self.count)
        self.average = self.total / n
        self.std_deviation = math.sqrt((self._sum_of_squares / n)
                                       - (self.average ** 2))

    def __str__(self):
        return "min=%i, max=%i, avg=%f, std-dev=%f" % (self.min, self.max, self.average, self.std_deviation)


class _Base(object):
    """Common base for all ombt2 processes.  Establishes a connection to the
    message bus and a subscription for control messages
    """
    def __init__(self, transport, exchange, topic):
        super(_Base, self).__init__()
        self._finished = threading.Event()
        self.name = 'ombt-%s-%s-%s-%s' % (topic,
                                          socket.gethostname(),
                                          os.getpid(),
                                          uuid.uuid4().hex)
        self.transport = transport
        self.exchange = exchange
        self.my_target = om.Target(exchange=exchange,
                                   topic=topic,
                                   server=self.name)
        self._my_server = om.get_rpc_server(transport,
                                              target=self.my_target,
                                              endpoints=[self])
        self._my_server.start()

    def start(self):
        ready = False
        attempts = 0
        logging.debug("%s connecting to the message bus...", self.name)
        client = om.RPCClient(self.transport,
                              target=self.my_target,
                              timeout=10)
        while not ready and attempts < 25:
            try:
                ready = client.call({}, 'self_ready')
            except om.MessagingTimeout:
                attempts += 1
        if not ready:
            raise Exception("Unable to contact message bus")
        logging.debug("%s is listening", self.name)

    def wait(self, timeout=None):
        return self._finished.wait(timeout)

    def _do_shutdown(self):
        self._my_server.stop()
        self._my_server.wait()
        self._finished.set()
        logging.debug("%s has shut down", self.name)

    #
    # RPC calls:
    #

    def shutdown(self, ctxt):
        # cannot synchronously shutdown server since this call is dispatched by
        # the server...
        threading.Thread(target=self._do_shutdown).start()

    def self_ready(self, ctxt):
        return True


class _Client(_Base):
    """Common base for non-controller clients
    """
    def __init__(self, transport, topic, kind):
        # listen on 'client-$topic' for controller commands:
        self.topic = CLIENT_TOPIC % topic
        self.kind = kind
        super(_Client, self).__init__(transport, 'ombt', self.topic)

    @abc.abstractmethod
    def run_test(self, ctxt, test, kwargs, reply_addr):
        """Called by the controller to have the client run test 'test' with
        arguments kwargs, send results to reply_target.  Note: this is an RPC
        method that is invoked by the test controller via 'cast' - not 'call'
        (controller must not block for results)
        """

    #
    # RPC Calls
    #
    def client_ping(self, ctxt, reply_addr):
        # invoked by controller via rpc-cast to roll-call available clients
        target = om.Target(**reply_addr)
        ctrl = om.RPCClient(self.transport, target=target)
        ctrl.cast({}, "client_pong", kind=self.kind, name=self.name)


class RPCTestClient(_Client):
    """Runs the RPC tests against the RPCTestServer
    """
    def __init__(self, transport, topic):
        super(RPCTestClient, self).__init__(transport,
                                            topic,
                                            RPC_CLIENT)
        # for calling the test RPC server:
        target = om.Target(exchange='ombt',
                           topic='rpc-server-%s' % topic)
        self._rpc_server = om.RPCClient(transport,
                                        target=target,
                                        timeout=30)
    #
    # RPC Calls:
    #

    def run_test(self, ctxt, test, kwargs, reply_addr):
        func = None
        verbose = kwargs.get("verbose", False)
        pause = kwargs.get("pause", 0)
        data = kwargs.get("data", "")
        count = kwargs.get("count", 0)

        if test == "test_call":
            func = lambda: self._rpc_server.call({}, 'echo', data=data)
        elif test == "test_cast":
            func = lambda: self._rpc_server.cast({}, 'noop', data=data)
        else:
            # ignore any unrecognized test, like 'notify'...
            return

        controller = om.RPCClient(self.transport, om.Target(**reply_addr), timeout=30)
        logging.debug("Client %s starting test %s ...", self.name, test)

        try:
            latency = Stats()
            calls = 0
            pause = float(pause)/1000.0
            stop = False
            t_start = now()
            while not stop:
                t = now()
                func()
                latency.update((now() - t) * 1000)
                if (pause): time.sleep(pause)
                calls += 1
                if (verbose and count and (calls % (max(10, count)/10) == 0)):
                    logging.info("Call %i of %i completed", calls, count)
                if count and calls >= count:
                    stop = True
            t_end = now() - t_start
            results = {'latency': latency.__dict__,
                       'throughput': calls/t_end,
                       'calls': calls}
        except Exception as ex:
            logging.error("Test failure: %s", str(ex))
            results = {'failure': str(ex)}

        controller.call({}, 'client_result', kind=self.kind, results=results)


class RPCTestServer(_Client):
    """Response to RPC requests from RPCTestClient
    """
    def __init__(self, transport, topic, executor):
        super(RPCTestServer, self).__init__(transport,
                                            topic,
                                            RPC_SERVER)
        target = om.Target(exchange='ombt',
                           topic='rpc-server-%s' % topic,
                           server=self.name)
        self._rpc_server = om.get_rpc_server(transport,
                                             target,
                                             [self],
                                             executor=executor)
        self._rpc_server.start()

    #
    # RPC Calls:
    #

    def shutdown(self, ctxt):
        self._rpc_server.stop()
        self._rpc_server.wait()
        super(RPCTestServer, self).shutdown(ctxt)

    def run_test(self, ctxt, test, kwargs, reply_addr):
        pass  # TBD - none for now

    def noop(self, ctxt, data):
        # for cast testing - called by RPCTestClient, no return value
        pass

    def echo(self, ctxt, data):
        # for call testing - called by RPCTestClient
        return data


class TestNotifier(_Client):
    """Client for issuing Notification calls to the TestListener
    """
    def __init__(self, transport, topic):
        super(TestNotifier, self).__init__(transport,
                                           topic,
                                           NOTIFIER)
        # for notifying the test listener:
        self._notifier = om.notify.notifier.Notifier(transport,
                                                     self.name,
                                                     driver='messaging',
                                                     topics=[topic])
    #
    # RPC Calls:
    #

    def run_test(self, ctxt, test, kwargs, reply_addr):
        if test != 'test_notify':
            # ignore other tests, like rpc-call, etc
            return
        verbose = kwargs.get("verbose", False)
        pause = kwargs.get("pause", 0)
        data = kwargs.get("data", "")
        count = kwargs.get("count", 0)
        severity = kwargs.get("severity", "debug")

        controller = om.RPCClient(self.transport, om.Target(**reply_addr), timeout=30)
        logging.debug("Client %s starting test %s ...", self.name, test)

        try:
            latency = Stats()
            calls = 0
            pause = float(pause)/1000.0
            func = getattr(self._notifier, severity)
            payload = {'payload': data}
            stop = False
            t_start = now()
            while not stop:
                t = now()
                func({}, "notification-test", payload)
                latency.update((now() - t) * 1000)
                if (pause): time.sleep(pause)
                calls += 1
                if (verbose and count and (calls % (max(10, count)/10) == 0)):
                    logging.info("Call %i of %i completed", calls, count)
                if count and calls >= count:
                    stop = True
            results = {'latency': latency.__dict__,
                       'throughput': calls/(now() - t_start),
                       'calls': calls}
        except Exception as ex:
            logging.error("Test failure: %s", str(ex))
            results = {'failure': str(ex)}

        controller.call({}, 'client_result', kind=self.kind, results=results)


class TestListener(_Client):
    def __init__(self, transport, topic, executor):
        super(TestListener, self).__init__(transport,
                                           topic,
                                           LISTENER)
        target = om.Target(exchange='ombt',
                           topic=topic,
                           server=self.name)
        self._listener = om.get_notification_listener(transport,
                                                      [target],
                                                      [self],
                                                      executor=executor)
        self._listener.start()

    #
    # RPC Calls:
    #

    def shutdown(self, ctxt):
        self._listener.stop()
        self._listener.wait()
        super(TestListener, self).shutdown(ctxt)

    def run_test(self, ctxt, test, kwargs, reply_addr):
        pass # TBD - none for now

    #
    # Notifications:
    #

    def _report(self, severity, ctx, publisher, event_type, payload, metadata):
        logging.debug("%s Notification %s:%s:%s:%s:%s", self.name, severity,
                      publisher, event_type, payload, metadata)

    def debug(self, ctx, publisher, event_type, payload, metadata):
        self._report("debug", ctx, publisher, event_type, payload, metadata)

    def audit(self, ctx, publisher, event_type, payload, metadata):
        self._report("audit", ctx, publisher, event_type, payload, metadata)

    def critical(self, ctx, publisher, event_type, payload, metadata):
        self._report("critical", ctx, publisher, event_type, payload, metadata)

    def error(self, ctx, publisher, event_type, payload, metadata):
        self._report("error", ctx, publisher, event_type, payload, metadata)

    def info(self, ctx, publisher, event_type, payload, metadata):
        self._report("info", ctx, publisher, event_type, payload, metadata)

    def warn(self, ctx, publisher, event_type, payload, metadata):
        self._report("warn", ctx, publisher, event_type, payload, metadata)


class Controller(_Base):
    """The test controller
    """
    def __init__(self, transport, topic, timeout):
        # each controller has a unique topic not to be confused
        # with future or past controller instances
        self.topic = topic
        self._timeout = timeout
        controller_topic = "controller-%s-%s" % (topic, uuid.uuid4().hex)
        super(Controller, self).__init__(transport, 'ombt', controller_topic)
        self._minions = dict()
        self._total_minions = 0
        self._latency = Stats()
        self._throughput = Stats()
        self._done = threading.Event()

    def start(self):
        super(Controller, self).start()
        target = om.Target(exchange=EXCHANGE,
                           topic=CLIENT_TOPIC % self.topic,
                           fanout=True)
        self._clients = om.RPCClient(self.transport, target=target)
        logging.debug("Polling for clients...")
        reply = {'exchange': self.my_target.exchange,
                 'topic': self.my_target.topic,
                 'server': self.my_target.server}
        self._clients.cast({}, 'client_ping', reply_addr=reply)
        time.sleep(1.0)  # allow some clients to respond

    def shutdown(self):
        """Shutdown all clients listening to $topic
        """
        self._clients.cast({}, 'shutdown')
        time.sleep(1.0)
        super(Controller, self).shutdown({})

    def run_call_test(self, count, data, verbose, pause):
        kwargs = {'verbose': verbose,
                  'pause': pause,
                  'data' : data,
                  'count' : count}
        self._start_test(RPC_CLIENT, 'test_call', kwargs)

    def run_cast_test(self, count, data, verbose, pause):
        kwargs = {'verbose': verbose,
                  'pause': pause,
                  'data' : data,
                  'count' : count}
        self._start_test(RPC_CLIENT, 'test_cast', kwargs)

    def run_notification_test(self, count, data, severity, verbose, pause):
        kwargs = {'verbose': verbose,
                  'pause': pause,
                  'data' : data,
                  'count' : count,
                  'severity': severity}
        self._start_test(NOTIFIER, 'test_notify', kwargs)

    def _start_test(self, kind, test, kwargs):
        if (kind not in self._minions
                or self._minions[kind] == 0):
            print("No %s clients visible" % kind)
            return -1

        self._result_count = 0
        self._op_count = 0
        self._latency.reset()
        self._throughput.reset()
        self._done.clear()
        start = time.time()
        reply = {'exchange': self.my_target.exchange,
                 'topic': self.my_target.topic,
                 'server': self.my_target.server}
        # tell all clients to run the test
        self._clients.cast({}, 'run_test',
                           test=test,
                           kwargs=kwargs,
                           reply_addr=reply)
        if not self._done.wait(self._timeout):
            print("%s test timed out!" % test)
        else:
            self._print_stats(time.time() - start)

    def _print_stats(self, duration):
        print("\n")
        print("Per-client average results (%s clients):"
              % self._result_count)
        print("  Latency (millisecs):    %s" % self._latency)
        print("  Throughput (ops/sec): %s" % self._throughput)
        print("Aggregated Throughput (ops/sec): %s over %s transactions"
              % ((self._op_count / duration), self._op_count))

    #
    # RPC calls:
    #
    def client_pong(self, ctxt, kind, name):
        # A client 'name' is checking in
        if kind not in self._minions:
            self._minions[kind] = 0
        self._minions[kind] += 1
        self._total_minions += 1
        logging.debug("New %s detected (%s) - %d total clients found",
                      kind, name, self._total_minions)

    def client_result(self, ctxt, kind, results):
        # A client is reporting a test result
        self._result_count += 1
        try:
            calls = results['calls']
            thruput = results['throughput']
            latency = results['latency']
        except KeyError:
            logging.error("Client reports test failure: %s",
                          results.get('failure', 'cause unknown'))
        else:
            self._op_count += calls
            l = Stats()
            l.__dict__.update(latency)
            self._latency.merge(l)
            self._throughput.update(thruput)
            logging.debug("  result %i of %i"
                          " - Throughput: %i, Latency:%s", self._result_count,
                          self._minions[kind], thruput, l)
        # todo(kgiusti): fix me - should allow time for counts to stabilize
        if self._result_count == self._minions[kind]:
            self._done.set()


def _parse_args(args, values):
    for i in range(len(args)):
        arg = args[i].lower()
        try:
            key, value = arg.split('=')
        except ValueError:
            print("Error - argument format is key=value")
            print(" - %s is not valid" % str(arg))
            raise SyntaxError("bad argument: %s" % arg)
        if key not in values:
            print("Error - unrecognized argument %s" % key)
            print(" - arguments %s" % [x for x in iter(values)])
            raise SyntaxError("unknown argument: %s" % key)
        values[key] = int(value) if isinstance(values[key], int) else value
    return values


def _do_shutdown(tport, cfg, args):
    controller = Controller(tport, args.topic, args.timeout)
    controller.start()
    controller.shutdown()


def _rpc_call_test(tport, cfg, args):
    controller = Controller(tport, args.topic, args.timeout)
    args = _parse_args(args.args, {'length': DEFAULT_LEN, 'calls': 1,
                                   'pause': 0, 'verbose': False})
    controller.start()
    controller.run_call_test(args['calls'], 'X' * args['length'],
                             args['verbose'], args['pause'])


def _rpc_cast_test(tport, cfg, args):
    controller = Controller(tport, args.topic, args.timeout)
    args = _parse_args(args.args, {'length': DEFAULT_LEN, 'calls': 1,
                                   'pause': 0, 'verbose': False})
    controller.start()
    controller.run_cast_test(args['calls'], 'X' * args['length'],
                             args['verbose'], args['pause'])


def _notify_test(tport, cfg, args):
    controller = Controller(tport, args.topic, args.timeout)
    args = _parse_args(args.args, {'length': DEFAULT_LEN, 'calls': 1,
                                   'severity': 'debug',
                                   'verbose': None,
                                   'pause' : 0})
    controller.start()
    controller.run_notification_test(args['calls'], 'X' * args['length'],
                                     args['severity'], args['verbose'],
                                     args['pause'])

def controller(tport, cfg, args):
    TESTS={'rpc-call': _rpc_call_test,
           'rpc-cast': _rpc_cast_test,
           'shutdown': _do_shutdown,
           'notify': _notify_test}
    func = TESTS.get(args.test.lower())
    if func is None:
        print("Error - unrecognized command %s" % args.test)
        print("commands: %s" % [x for x in iter(TESTS)])
        return -1
    return func(tport, cfg, args)


def rpc_standalone(tport, cfg, args):
    server = RPCTestServer(tport,
                           args.topic,
                           args.executor)
    server.start()
    client = RPCTestClient(tport, args.topic)
    client.start()

    controller = Controller(tport, args.topic, args.timeout)
    controller.start()

    if args.do_cast:
        controller.run_cast_test(args.calls,
                                 'X' * args.length,
                                 args.debug, 0)
    else:
        controller.run_call_test(args.calls,
                                 'X' * args.length,
                                 args.debug, 0)
    controller.shutdown()


def notify_standalone(tport, cfg, args):
    server = TestListener(tport,
                          args.topic,
                          args.executor)
    server.start()
    client = TestNotifier(tport, args.topic)
    client.start()

    controller = Controller(tport, args.topic, args.timeout)
    controller.start()
    controller.run_notification_test(args.calls,
                                     'X' * args.length,
                                     'debug', # todo: fix
                                     args.debug, 0)
    controller.shutdown()


def _run_as_daemon():
    #
    # run the command in a child process
    #
    cmdline = sys.argv[:]
    cmdline.remove("--daemon")
    cmdline.append("-X-daemon")
    if 'python' not in cmdline[0]:
        # hack to run correctly under virtualenv
        cmdline = [sys.executable] + cmdline

    p = os.pipe()
    child = Popen(cmdline, bufsize=0, stderr=STDOUT, stdout=p[1])
    out = ""
    while True:
        b = os.read(p[0], 1000)
        # hack, why doesn't os.read() return when the pipe is closed???
        if not b or b[-1] == '\n':
            break
        out += b
    print("%s" % out)


def rpc_server(tport, cfg, args):
    server = RPCTestServer(tport, args.topic, args.executor)
    server.start()
    if _DAEMON:
        os.write(_PARENT_FD, "RPC server %s is ready\n" % server.name)
        os.close(_PARENT_FD)
    server.wait()


def rpc_client(tport, cfg, args):
    client = RPCTestClient(tport, args.topic)
    client.start()
    if _DAEMON:
        os.write(_PARENT_FD, "RPC client %s is ready\n" % client.name)
        os.close(_PARENT_FD)
    client.wait()


def listener(tport, cfg, args):
    listener = TestListener(tport, args.topic, args.executor)
    listener.start()
    if _DAEMON:
        os.write(_PARENT_FD, "Listener %s is ready\n" % listener.name)
        os.close(_PARENT_FD)
    listener.wait()


def notifier(tport, cfg, args):
    notifier = TestNotifier(tport, args.topic)
    notifier.start()
    if _DAEMON:
        os.write(_PARENT_FD, "Notifier %s is ready\n" % notifier.name)
        os.close(_PARENT_FD)
    notifier.wait()


def main():
    parser = argparse.ArgumentParser(
        description='Benchmark tool for oslo.messaging')

    parser.add_argument("--url",
                        default='rabbit://localhost:5672',
                        help="The address of the messaging service")
    parser.add_argument("--oslo-config",
                        help="oslo.messaging configuration file")
    parser.add_argument('--topic', default='test-topic',
                        help='service address to use')
    parser.add_argument('--debug', action='store_true',
                        help='Enable DEBUG logging')
    parser.add_argument("--timeout", type=int, default=None,
                        help='fail test after timeout seconds')

    subparsers = parser.add_subparsers(dest='mode',
                                       description='operational mode')
    # RPC Standalone
    sp = subparsers.add_parser('rpc',
                               description='standalone RPC test')
    sp.add_argument("--calls", type=int, default=1,
                    help="Number of RPC calls to perform")
    sp.add_argument("--length", type=int, default=DEFAULT_LEN,
                    help='length in bytes of payload string')
    sp.add_argument("--cast", dest='do_cast', action='store_true',
                    help='RPC cast instead of RPC call')
    sp.add_argument("--executor", default="threading",
                    help="type of executor the server will use")

    # Notification Standalone
    sp = subparsers.add_parser('notify',
                               description='standalone notification test')
    sp.add_argument("--calls", type=int, default=1,
                    help="Number of RPC calls to perform")
    sp.add_argument("--length", type=int, default=DEFAULT_LEN,
                    help='length in bytes of payload string')
    sp.add_argument("--executor", default="threading",
                    help="type of executor the server will use")

    # Test controller
    sp = subparsers.add_parser('controller',
                               description='Controller mode')
    sp.add_argument("test", help='the test to run')
    sp.add_argument('args', nargs='*', help='test arguments')

    # RPC Server
    sp = subparsers.add_parser('rpc-server',
                               description='RPC Server mode')
    sp.add_argument("--daemon", action='store_true',
                    help='Run the server in the background')
    sp.add_argument("--executor", default="threading",
                    help="type of executor the server will use")

    # RPC Client
    sp = subparsers.add_parser('rpc-client',
                               description='RPC Client mode')
    sp.add_argument("--daemon", action='store_true',
                    help='Run the client in the background')

    # Listener
    sp = subparsers.add_parser('listener',
                               description='Notification listener mode')
    sp.add_argument("--executor", default="threading",
                    help="type of executor the server will use")
    sp.add_argument("--daemon", action='store_true',
                    help='Run the listener in the background')

    # Notifier
    sp = subparsers.add_parser('notifier',
                               description='Notifier mode')
    sp.add_argument("--daemon", action='store_true',
                    help='Run the notifier in the background')

    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.debug else logging.WARN)

    # run in the background if specified:
    if getattr(args, 'daemon', False):
        return _run_as_daemon()

    cfg.CONF.transport_url=args.url
    if args.oslo_config:
        cfg.CONF(["--config-file", args.oslo_config])

    tport = om.get_transport(cfg.CONF)

    {'controller': controller,
     'rpc': rpc_standalone,
     'rpc-server': rpc_server,
     'rpc-client': rpc_client,
     'notify': notify_standalone,
     'listener': listener,
     'notifier': notifier}[args.mode](tport, cfg, args)

    return None


if __name__ == "__main__":

    # determine if this command is running in
    # the background:
    if '-X-daemon' in sys.argv:

        _DAEMON = True

        # the parent process is waiting for this process to print that it is
        # ready on stdout so it can block until the child is done initializing
        # re-direct stdio to devnull to avoid any spurious output from causing
        # the parent to unblock prematurely

        _PARENT_FD = os.dup(sys.stdout.fileno())
        os.dup2(os.open(os.devnull, os.O_RDONLY), sys.stdin.fileno())
        os.dup2(os.open(os.devnull, os.O_WRONLY), sys.stdout.fileno())
        os.dup2(os.open(os.devnull, os.O_WRONLY), sys.stderr.fileno())
        #os.dup2(os.open("/home/kgiusti/tmp/STDOUT", os.O_WRONLY | os.O_CREAT |
        #                os.O_TRUNC), sys.stdout.fileno())
        #os.dup2(os.open("/home/kgiusti/tmp/STDERR", os.O_WRONLY | os.O_CREAT |
        #                os.O_TRUNC), sys.stderr.fileno())

        sys.argv.remove('-X-daemon')

    sys.exit(main())

